\chapter{Introduction}

In this report, we describe the design and implementation of a highly
efficient library for parallel execution of new, globally synchronous,
message passing framework called Synchronous Message Exchange
(SME). We will present a parallel, compiled framework, named
C++SME, which can be used to implement and execute applications
using the SME model.

The remainder of this chapter, will describe and define the SME
model. The second chapter will describe the process behind designing
C++SME. In the third chapter we will describe the implementation
process and finally, we will show the benchmarks performed of our
implementation.


\section{Background and Motivation}
In the pursuit of performance and energy efficiency, alternatives to
traditional CPU's has been extensively researched in recent years. A
lot of this research has been centered around taking advantage of the
massive parallelism supported by GPUs in general purpose
computing. Another technology which can be used to achieve this goal
is Field-programmable Gate Arrays (FPGA). As their name suggests,
FPGAs are integrated circuits whose function can be altered after
manufacturing

While FPGAs provides several advantages over using for processing work
including a significantly improved performance-per-watt ratio, their
widespread adoptation\fxnote{find right word} are limited by the lack
of tools which allows ordinary programmers to adapt their applications
to run a FPGA. Currently, Today, FPGAs are programmed using Hardware
Description Languages which enable programmers to specify the design
of the FPGA in a low-level manner. Due to this, their use are largely
restricted to engineers with working knowledge in the field of
hardware design. In order for software developers to take advantage of
FPGAs, improved high-level hardware design utilities are required
\cite{bacon2013fpga}.

In an attempt to improve this situation, a master thesis explored
using PyCSP to define hardware designs and synthesize them into
Hardware Description Languages. Since CSP is based on the idea that
any process can communicate at any time, the primary challenge that
arose was how to model the clock-driven global synchrony that exists
in hardware using CSP. Their solution was to add a central
clock process which all processes in the network had to read from in
order to know when communication was allowed. Furthermore,
latch-processes had to be inserted between processes in order to
control value propagation. This required the addition of channels from
the clock process to every process in the network. This explosion of
the number of channels proved difficult to manage and even though they
successfully managed to synthesize simple CSP networks into HDL's, the
feasibility of taking a pure CSP approach to hardware design was
discredited.

Some properties of CSP, however, proved to be useful in relation to
hardware design. Particularly the shared-nothing property of CSP
processes.

These experiences and observations lead to the conception of a new
messaging framework called Synchronous Message Exchange (SME) which
aims to preserve the properties of CSP that proved useful in hardware
designs (such as shared-nothing) and combining them with properties that
enforces a hardware-like paradigm such as global synchrony and an
implicit clock \cite{vinter2014synchronous}.

The aim of this project is to attempt to implement a parallelized
execution environment for SME in order to improve the speed of which
the systems that is modeled can be simulated.


%SME is an attempt to provide a programming framework that, while
%leveraging and maintaining the properties of CSP that proved useful
%and f enforcing a hardware-like paradigm, that is accessible to
%software developers. By \cite{vinter2014synchronous}

\section{Synchronous Message Exchange}
In this section, we elaborate on the description of SME from the
previous section.

We would like to start by defining the terms used henceforth in this
report to avoid any ambiguities.

%Many of the terms used, have a
%specific meaning when used to describe computer hardware and this
%meaning will generally give a good idea of the meaning of a term in
%SME.


\subsection{Definitions}

\begin{description}
  \item[Network] A network is the highest level structure in the
    SME-model. It is simply a network of processes connected by buses
  \item[Cycle] During a cycle (\cref{fig:cycle}, all processes
    executes and all busses propagates their values. A cycle goes
    through two distinct phases which we will refer to as the process
    execution phase and the value propagation phase. The process
    execution phase will activate all the execution units of the
    processes in the network to allow them to perform data
    calculation. The value propagation phase will transfer the
    output-values generated by processes in the current cycle, to
    serve as input-values in the next cycle.
\end{description}
\begin{figure}
\centering
\includegraphics{figures/execution-cycle}
\caption[Execution flow of a SME-process]{The execution cycle of a
  SME process visualized as a hardware clock-cycle. Before every cycle
  data from a input bus is read into the process and after a cycle,
  data is written back to the gate. Reproduction of figure from \cite{vinter2014synchronous}}
\label{fig:cycle}
\end{figure}


\subsection{Components}
Compared to CSP, a much smaller and simpler set of components are used
to model the process network. In this section, we describe those
components

\begin{description}
\item[Process] A process is an execution unit performing a unit of
  work. A process is defined by input and output busses used for
  communicating with other processes in the network and function which
  is called when the process is executed. The internal state of a
  process persistent between executions, but it's execution cannot
  have any side-effects. Thus, the only way the execution of a process
  can alter the state of other processes is by bus
  communication. \fxnote{Isn't it really the other way around?}
\item[Bus] A bus enables communication between processes and should be
  considered analogous to buses found in actual hardware. A bus
  consists of a writing-slot and a reading-slot, both of which can
  hold a (signed integer/single FIXME) value. A bus in SME implements the
  CSP-equivalent of a one-to-all channel with a one message
  overwrite-buffer which means that only the final value written to
  the writing-slot will persist in the next cycle. The value of the
  reading-slot, on the other hand, can be read by all connected
  processes during a cycle. The value of the reading-slot is
  idempotent and is guaranteed to remain constant during the process
  execution phase of a cycle. During the value-propagation phase of a
  cycle the value of the writing-slot is copied to the
  reading-slot. From the point of view of the processes, the
  value-propagation phase is atomic, meaning that the values of all
  buses can be observed changing ``at conce''. If no value is written
  the writing-slot of a bus during a cycle, the value of its
  writing-slot will be 0 in the subsequent cycle.

\end{description}

\subsection{Properties}
The SME model has a number of special properties which must be
maintained in order to ensure correct execution of the network. These
properties also influences the design of our execution model.

\begin{property}[Implicit clock] One defining feature of
    hardware is that all processing is driven by a clock beat. In
    order to maintain this feature in SME, we introduce a simulated
    clock beat in our implementation of SME and thus the defining
    property of hardware is preserved in the SME model.
\end{property}

\begin{property}[Global synchrony]
  % http://eyes4earth.org/2014/11/synchronicity-or-synchrony/
  \label{synchro}
  As a consequence of implementing the simulated clock best, all
  events and communications of the network occurs completely
  synchronous from the point of view of a process. FIXME
\end{property}

\begin{property}[Shared Nothing]
  \label{noshare}
  A process is completely autonomous and can only change state through
  receiving a message on its incoming bus. A process is also self
  contained in the sense
\end{property}



\section{Limitations}
This report will not discuss details related to design of hardware

\section{Related work}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "master"
%%% TeX-command-extra-options: "-enable-write18"
%%% End:
