\chapter{Implementation}

We have chosen to implement the SME library in the C++ language. C++
combines the availability of high-level structures, such as classes,
with the ability to, when needed, assert low-level control over the
code generated. Furthermore, the C++11 revision of the language allows
for easy access to features that were previously hard to use. Such
feature include the <atomics> header which enables the use of atomic
instructions and enforced memory ordering without the need for inline
assembly and similar. Having access to atomics is a highly desire able
feature for us since they can be used as high-performance
synchronization primitives. Furthermore, classes in C++ are well suited for
representing SME constructs and specifically, they provide a natural
enclosure of the state maintained by a SME process.

The library is meant to be imported by applications wishing to take
advantage of the SME-model.

The implementation was performed in several phases. The initial
version of the C++SME code was purely single-threaded and was
implemented to play around with the C++ API's and for defineing the
API used to define SME networks.

Adding support for multi-threading required a lot of the code from the
initial single-threaded implementation to be refactored and rewritten.

Since the networks that we benchmark are large enough that it would be
tedious to write them by hand, features were also added mainly for the
purpose of supporting benchmarking.  ur initial approach to
benchmarking used python script for generating the benchmark networks,
however, this method quickly proved to be in infeasible since GCC's
compilation time increases, seamingly, exponentially with the amount
of objects defined in the code being compiled. We therefore had to
enable the SME-library to support runtime definition of networks. Mind
you, that networks are still statically defined in the sense that the
orchestration of processes must be performed before the start of
network execution. Networks that change at runtime is beyond the scope
of SME since it simply isn't possible in hardware, which SME is
intended to map \fxnote{rewrite}

Since 

We want the API to be as seamless as possible, that is, it should get
int he way of the programmer as little as possible. Several phases of
refinement led to the current API which reduces the amount of
boilerplate code required  significantly compared to the original version

\section{Initial implementation}
Our initial implementation was a sequential implementation of the
SME execution environment. This implementation was done simply, as a
proof of concept and to experiment with different API's for defining
SME networks.

\section{Queue implementation}
How we performed process orchestration and, in particular, the
workqueue mechanism got a lot of attention in the previous chapter. In
this section, we will how we made the actual implementations of the
work queues

The locking mechanisms used in sought 

\subsection{Locking mechanisms and atomics}
Atomics, and particularlily lockless algorithms have recently been
made availible for ``casual'' use by programmer following their
inclusion in recent language revisions.

https://www.arangodb.com/2015/02/comparing-atomic-mutex-rwlocks/

\section{Design goals}
The library takes advantage of the fact that the initial process
orchestration is only executed once and thus can be implemented with
focus on code clarity rather than performance. This 

\section{Public API}
Boilerplate code is a major annoyance 

\section{Testing}
In order to check that our network works as intended and is able to
execute a SME network without violating any of the properties of the
SME model, we have implemented a special \textit{validator network}
which is design to reveal any inconsistencies arising from
incohesion\fxnote{is this a word?} with the invariants of the SME
model.

Specifically, the validator network intends to check if all processes
has been executed during a cycle and b) if all values 


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "master"
%%% TeX-command-extra-options: "-enable-write18"
%%% End:
